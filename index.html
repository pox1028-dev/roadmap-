<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Roadmap｜大路 + 下三路（完整賭場版）</title>
<style>
  :root{
    --bg:#0f172a; --card:#0b1220; --muted:#94a3b8;
    --grid:#d1d5db; --grid-dark:#334155;
    --red:#e11d48; --blue:#2563eb; --green:#10b981;
  }
  *{box-sizing:border-box}
  body{margin:0; background:var(--bg); color:#e5e7eb; font-family:"Microsoft JhengHei",system-ui,-apple-system,ui-sans-serif,Segoe UI,Roboto,Noto Sans TC,Arial}
  header{padding:10px 14px; background:linear-gradient(180deg,rgba(11,18,32,.95),rgba(11,18,32,.85)); border-bottom:1px solid #1f2937; position:sticky; top:0; z-index:50}
  .wrap{max-width:1200px; margin:0 auto; padding:14px}
  .row{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
  .grow{flex:1}
  button{appearance:none; border:0; border-radius:10px; padding:10px 14px; font-weight:600; color:#fff; cursor:pointer; box-shadow:0 8px 20px rgba(0,0,0,.25); transition:.2s transform ease}
  button:active{transform:translateY(1px)}
  .btn-b{background:var(--red)} .btn-p{background:var(--blue)} .btn-t{background:var(--green)} .btn-c{background:#64748b}
  .btn-pair{background:#374151}
  .panel{background:#111827; border:1px solid #1f2937; border-radius:12px; padding:12px; margin-bottom:14px; box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .stats{display:flex; gap:16px; align-items:center; flex-wrap:wrap; padding:8px 10px; background:#0b1220; border:1px solid #243042; border-radius:10px}
  .stat{display:flex; align-items:center; gap:8px; font-size:14px}
  .dot{width:10px; height:10px; border-radius:50%}
  .dot.red{background:var(--red)} .dot.blue{background:var(--blue)} .dot.green{background:var(--green)}
  .label{font-size:12px; color:var(--muted)}
  .boards{display:grid; grid-template-columns:repeat(auto-fit, minmax(340px,1fr)); gap:14px}
  .board h3{margin:2px 0 10px 6px; font-size:14px; color:#cbd5e1; letter-spacing:.3px}

  /* 賭場格子皮膚 */
  .road{ background:#fff; border-radius:10px; padding:8px; border:1px solid var(--grid-dark); overflow:auto; }
  .grid{ display:grid; grid-template-columns: repeat(42, 28px); grid-template-rows: repeat(6, 28px); gap:0; }
  .cell{ width:28px; height:28px; border:1px solid var(--grid); position:relative; }

  /* 大路：實心圓；和：右上小綠點 */
  .disc{ border-radius:50%; width:22px; height:22px; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); }
  .disc.red{ background:var(--red) } .disc.blue{ background:var(--blue) }
  .tieMark{ position:absolute; right:2px; top:2px; width:8px; height:8px; background:var(--green); border-radius:50%; box-shadow:0 0 0 2px #fff; }

  /* 大眼仔：空心粗圈 */
  .ring{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:22px; height:22px; border-radius:50%; box-shadow: inset 0 0 0 3px var(--blue); }
  .ring.red{ box-shadow: inset 0 0 0 3px var(--red); }

  /* 小路：小實心點 */
  .tiny{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:10px; height:10px; border-radius:50%; background:var(--blue); }
  .tiny.red{ background:var(--red); }

  /* 蟑螂路：斜線 */
  .slash::before{
    content:""; position:absolute; left:50%; top:50%; width:2px; height:18px; transform:translate(-50%,-50%) rotate(45deg);
    background:var(--blue);
  }
  .slash.red::before{ background:var(--red); }

  .hint{font-size:12px; color:#94a3b8; margin-top:6px}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <div class="row">
        <button class="btn-b" onclick="add('B')">莊</button>
        <button class="btn-p" onclick="add('P')">閒</button>
        <button class="btn-t" onclick="add('T')">和</button>
        <button class="btn-c" onclick="clearAll()">清除全部</button>
      </div>
      <div class="row">
        <button class="btn-pair" onclick="togglePair('B')">莊對</button>
        <button class="btn-pair" onclick="togglePair('P')">閒對</button>
      </div>
      <div class="grow"></div>
      <div class="stats">
        <div class="stat"><span class="dot red"></span>莊 <b id="sB">0</b></div>
        <div class="stat"><span class="dot blue"></span>閒 <b id="sP">0</b></div>
        <div class="stat"><span class="dot green"></span>和 <b id="sT">0</b></div>
        <div class="stat">莊對 <b id="sBP">0</b></div>
        <div class="stat">閒對 <b id="sPP">0</b></div>
        <div class="stat">總數 <b id="sN">0</b></div>
      </div>
    </div>
  </div>
</header>

<div class="wrap">
  <div class="panel"><div class="label">操作：先點「莊/閒/和」記錄一手；若該手出現對子，再點「莊對/閒對」切換。若最後一手是和，對子會套用到最近一筆非和的那手。</div></div>

  <div class="boards">
    <div class="panel">
      <h3>大路</h3>
      <div class="road"><div id="main" class="grid"></div></div>
    </div>
    <div class="panel">
      <h3>大眼仔路</h3>
      <div class="road"><div id="big" class="grid"></div></div>
    </div>
    <div class="panel">
      <h3>小路</h3>
      <div class="road"><div id="small" class="grid"></div></div>
    </div>
    <div class="panel">
      <h3>蟑螂路</h3>
      <div class="road"><div id="roach" class="grid"></div></div>
    </div>
  </div>
</div>

<script>
  const ROWS=6, COLS=42;
  // 每手結構：{res:'B'|'P'|'T', bp:false, pp:false}
  let hands = [];
  let lastPos = null, lastColor = null; // 給大路排版

  function add(x){ hands.push({res:x, bp:false, pp:false}); render(); }
  function clearAll(){ hands=[]; lastPos=null; lastColor=null; render(); }

  // 切換莊/閒對：作用在「最近一手非和」上（若最後是和，會往前找）
  function togglePair(which){
    for(let i=hands.length-1;i>=0;i--){
      if(hands[i].res!=='T'){
        if(which==='B') hands[i].bp = !hands[i].bp;
        if(which==='P') hands[i].pp = !hands[i].pp;
        break;
      }
    }
    render();
  }

  function stats(){
    let sB=0,sP=0,sT=0,sBP=0,sPP=0;
    for(const h of hands){
      if(h.res==='B') sB++;
      if(h.res==='P') sP++;
      if(h.res==='T') sT++;
      if(h.bp) sBP++;
      if(h.pp) sPP++;
    }
    document.getElementById('sB').textContent=sB;
    document.getElementById('sP').textContent=sP;
    document.getElementById('sT').textContent=sT;
    document.getElementById('sBP').textContent=sBP;
    document.getElementById('sPP').textContent=sPP;
    document.getElementById('sN').textContent=hands.length;
  }

  function render(){
    stats();
    const seq = hands.map(h=>h.res);
    const grid = buildMainGrid(seq);
    paintMain(grid);

    const cols = extractCols(grid);
    paintDerived('big', buildDerived(cols,2),'ring');     // 大眼仔：粗圈
    paintDerived('small', buildDerived(cols,3),'tiny');   // 小路：小實心點
    paintDerived('roach', buildDerived(cols,4),'slash');  // 蟑螂：斜線
  }

  // 大路：與你之前要求一致（實心圓、和疊點、同色往下/被擋階梯、變色換列）
  function buildMainGrid(list){
    const grid = Array.from({length:ROWS},()=>Array(COLS).fill(''));
    let row=0, col=0; lastColor=null; lastPos=null;
    for(const r of list){
      if(r==='T'){
        if(lastPos){ grid[lastPos.row][lastPos.col] += 'T'; }
        continue;
      }
      if(!lastColor){
        grid[row][col]=r; lastColor=r; lastPos={row,col}; continue;
      }
      if(r===lastColor){
        if(lastPos.row+1<ROWS && !grid[lastPos.row+1][lastPos.col]){
          row=lastPos.row+1; col=lastPos.col;
        }else{
          row=lastPos.row; col=lastPos.col+1;
          while(col<COLS && grid[row][col]) col++;
        }
      }else{
        row=0; col=lastPos.col+1;
        while(col<COLS && grid[row][col]) col++;
        lastColor=r;
      }
      if(col<COLS){ grid[row][col]=r; lastPos={row,col}; }
    }
    return grid;
  }

  function paintMain(grid){
    const root=document.getElementById('main');
    root.innerHTML='';
    // 需要知道每格對應到第幾手，來顯示對子？對子通常不畫在大路格內，只在統計列顯示；保留現在做法（統計列顯示數字即可）。
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const v = grid[r][c];
        const cell=document.createElement('div');
        cell.className='cell';
        if(v.includes('B')||v.includes('P')){
          const disc=document.createElement('div');
          disc.className='disc ' + (v.includes('B')?'red':'blue');
          cell.appendChild(disc);
        }
        if(v.includes('T')){
          const t=document.createElement('div');
          t.className='tieMark';
          cell.appendChild(t);
        }
        root.appendChild(cell);
      }
    }
  }

  function extractCols(grid){
    const cols=[];
    for(let c=0;c<COLS;c++){
      const col=[];
      for(let r=0;r<ROWS;r++){
        const v=grid[r][c];
        if(v.includes('B')||v.includes('P')) col.push(v);
      }
      if(col.length) cols.push(col);
    }
    return cols;
  }

  // 下三路：offset=2/3/4，存在性相同=紅，不同=藍
  function buildDerived(cols, offset){
    const out=[];
    for(let c=1;c<cols.length;c++){
      const cur=cols[c];
      for(let r=offset-1;r<cur.length;r++){
        const leftHas = (cols[c-1] && cols[c-1][r-1]!==undefined);
        const refIdx = c - offset;
        const refHas  = (cols[refIdx] && cols[refIdx][r-1]!==undefined);
        out.push( (leftHas===refHas)?'R':'B' );
      }
    }
    return out;
  }

  function paintDerived(id, arr, style){
    const root=document.getElementById(id);
    root.innerHTML='';
    const max=ROWS*COLS;
    for(let i=0;i<max;i++){
      const cell=document.createElement('div');
      cell.className='cell';
      const v=arr[i];
      if(v){
        if(style==='ring'){
          const el=document.createElement('div');
          el.className='ring'+(v==='R'?' red':'');
          cell.appendChild(el);
        }else if(style==='tiny'){
          const el=document.createElement('div');
          el.className='tiny'+(v==='R'?' red':'');
          cell.appendChild(el);
        }else if(style==='slash'){
          cell.className += ' slash'+(v==='R'?' red':'');
        }
      }
      root.appendChild(cell);
    }
  }

  render();
</script>
</body>
</html>
