<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>百家樂路單 Roadmap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-slate-950 text-slate-100">
  <div id="root"></div>

  <script type="text/babel">
    const B="B", P="P", T="T";
    const ROWS=6, COLS=80, BEAD_COLS=10;

    const useLocalState=(key,init)=>{
      const [s,setS]=React.useState(()=>{try{return JSON.parse(localStorage.getItem(key))||init;}catch{return init;}});
      React.useEffect(()=>{try{localStorage.setItem(key,JSON.stringify(s));}catch{}},[s]);
      return [s,setS];
    };

    // ---------- 大路 ----------
    function buildBigRoad(seq){
      const nodes=[]; let last=null; const grid={};
      const k=(c,r)=>`${c}:${r}`;
      for(const x of seq){
        if(x===T){ if(last) last.ties=(last.ties||0)+1; continue; }
        if(!last){ last={c:0,r:0,who:x}; nodes.push(last); grid[k(0,0)]=last; continue; }
        if(x!==last.who){ last={c:last.c+1,r:0,who:x}; nodes.push(last); grid[k(last.c,0)]=last; }
        else{
          let c=last.c, r=last.r+1;
          if(r>=ROWS || grid[k(c,r)]){ c=c+1; r=0; }
          last={c,r,who:x}; nodes.push(last); grid[k(c,r)]=last;
        }
      }
      return nodes;
    }

    function bigRoadColumns(nodes){
      const map=new Map();
      for(const n of nodes){ if(!map.has(n.c)) map.set(n.c,[]); map.get(n.c).push(n); }
      for(const v of map.values()) v.sort((a,b)=>a.r-b.r);
      const max=Math.max(0,...map.keys());
      return Array.from({length:max+1},(_,i)=>map.get(i)||[]);
    }

    // ---------- 下三路（第一版規律判斷邏輯） ----------
    /*
     * 大眼仔起算點：第2欄
     * 小路起算點：第3欄
     * 蟑螂路起算點：第4欄
     * r>0 (同欄往下)：比較前N欄是否有子
     * r==0 (新開欄)：比較兩欄高度是否相等
     */
    function deriveRoads(nodes){
      const cols=bigRoadColumns(nodes).map(c=>({len:c.length}));
      const bigEye=[], small=[], cockroach=[];
      for(const n of nodes){
        const {c,r}=n;
        if(r>0){
          if(c>=1) bigEye.push({color:(cols[c-1]?.len||0)>r? "R":"B"});
          if(c>=2) small.push({color:(cols[c-2]?.len||0)>r? "R":"B"});
          if(c>=3) cockroach.push({color:(cols[c-3]?.len||0)>r? "R":"B"});
        }else{
          if(c>=2) bigEye.push({color:(cols[c-1]?.len||0)===(cols[c-2]?.len||0)? "R":"B"});
          if(c>=3) small.push({color:(cols[c-1]?.len||0)===(cols[c-3]?.len||0)? "R":"B"});
          if(c>=4) cockroach.push({color:(cols[c-1]?.len||0)===(cols[c-4]?.len||0)? "R":"B"});
        }
      }
      return {bigEye,small,cockroach};
    }

    // ---------- 珠盤路 (上→下、左→右) ----------
    function BeadPlate({seq}){
      const grid=Array.from({length:ROWS},()=>Array(BEAD_COLS).fill(null));
      seq.forEach((x,i)=>{
        const col=Math.floor(i/ROWS);
        const row=i%ROWS;
        if(col<BEAD_COLS) grid[row][col]=x;
      });
      return (
        <div className="inline-grid" style={{gridTemplateColumns:`repeat(${BEAD_COLS},18px)`}}>
          {grid.map((row,ri)=>(
            <React.Fragment key={ri}>
              {row.map((x,ci)=>(
                <div key={ci} className="w-[18px] h-[18px] border border-slate-700 flex items-center justify-center">
                  {x && (x===T
                    ? <div className="w-4 h-4 border-2 border-emerald-400 rounded-full" title="T"/>
                    : <div className={`w-4 h-4 rounded ${x===B?"bg-red-500":"bg-blue-500"}`} title={x}/>
                  )}
                </div>
              ))}
            </React.Fragment>
          ))}
        </div>
      );
    }

    // ---------- 大路顯示 ----------
    function BigRoad({nodes}){
      const grid=Array.from({length:ROWS},()=>Array(COLS).fill(null));
      for(const n of nodes){ if(n.c<COLS && n.r<ROWS) grid[n.r][n.c]=n; }
      return (
        <div className="overflow-x-auto">
          <div className="inline-grid" style={{gridTemplateColumns:`repeat(${COLS},18px)`}}>
            {grid.map((row,ri)=>(
              <React.Fragment key={ri}>
                {row.map((n,ci)=>(
                  <div key={ci} className="w-[18px] h-[18px] border border-slate-700 flex items-center justify-center">
                    {n && (
                      <div className={`w-4 h-4 rounded-full ${n.who===B?"bg-red-500":"bg-blue-500"} relative`} title={n.who}>
                        {n.ties ? <span className="absolute text-[10px] text-white">{n.ties}</span> : null}
                      </div>
                    )}
                  </div>
                ))}
              </React.Fragment>
            ))}
          </div>
        </div>
      );
    }

    // ---------- 下三路顯示（左→右、上→下） ----------
    function DerivedRoad({dots,symbol}){
      const grid=Array.from({length:ROWS},()=>Array(COLS).fill(null));
      let idx=0;
      for(const d of dots){
        const r=Math.floor(idx/COLS);
        const c=idx%COLS;
        if(r<ROWS) grid[r][c]=d;
        idx++;
      }
      return (
        <div className="overflow-x-auto">
          <div className="inline-grid" style={{gridTemplateColumns:`repeat(${COLS},18px)`}}>
            {grid.map((row,ri)=>(
              <React.Fragment key={ri}>
                {row.map((d,ci)=>(
                  <div key={ci} className="w-[18px] h-[18px] border border-slate-700 flex items-center justify-center">
                    {d && (symbol==="/"
                      ? <span className={`${d.color==="R"?"text-red-400":"text-blue-400"} text-[14px]`}>/</span>
                      : <span className={`${d.color==="R"?"text-red-400":"text-blue-400"} ${symbol==="●"?"text-[16px]":"text-[14px]"}`}>{symbol}</span>
                    )}
                  </div>
                ))}
              </React.Fragment>
            ))}
          </div>
        </div>
      );
    }

    // ---------- 主程式 ----------
    function App(){
      const [st,setSt]=useLocalState("bacc_full",{seq:[]});
      const add=x=>setSt(s=>({...s,seq:[...s.seq,x]}));
      const undo=()=>setSt(s=>({...s,seq:s.seq.slice(0,-1)}));
      const reset=()=>setSt({seq:[]});

      const nodes=buildBigRoad(st.seq);
      const {bigEye,small,cockroach}=deriveRoads(nodes);

      return (
        <div className="max-w-[1200px] mx-auto p-4 space-y-4">
          <h1 className="text-xl font-bold">百家樂路單 · 完整版</h1>
          <div className="flex flex-wrap gap-2">
            <button onClick={()=>add(B)} className="px-4 py-2 rounded-2xl bg-red-600 text-white">莊 (B)</button>
            <button onClick={()=>add(P)} className="px-4 py-2 rounded-2xl bg-blue-600 text-white">閒 (P)</button>
            <button onClick={()=>add(T)} className="px-4 py-2 rounded-2xl bg-emerald-600 text-white">和 (T)</button>
            <button onClick={undo} className="px-3 py-2 rounded-2xl bg-slate-700">悔步</button>
            <button onClick={reset} className="px-3 py-2 rounded-2xl bg-slate-700">重置</button>
          </div>

          <div className="grid lg:grid-cols-5 md:grid-cols-2 gap-4">
            <div className="bg-slate-900 rounded-2xl p-4 shadow"><h2 className="mb-2 font-semibold">珠盤路</h2><BeadPlate seq={st.seq}/></div>
            <div className="bg-slate-900 rounded-2xl p-4 shadow"><h2 className="mb-2 font-semibold">大路</h2><BigRoad nodes={nodes}/></div>
            <div className="bg-slate-900 rounded-2xl p-4 shadow"><h2 className="mb-2 font-semibold">大眼仔</h2><DerivedRoad dots={bigEye} symbol="●"/></div>
            <div className="bg-slate-900 rounded-2xl p-4 shadow"><h2 className="mb-2 font-semibold">小路</h2><DerivedRoad dots={small} symbol="○"/></div>
            <div className="bg-slate-900 rounded-2xl p-4 shadow"><h2 className="mb-2 font-semibold">蟑螂路</h2><DerivedRoad dots={cockroach} symbol="/"/></div>
          </div>

          <p className="text-xs text-slate-400">說明：下三路紅/藍代表規律/不規律（與莊/閒無關）。和局不推進，只在當前大路格標記次數。</p>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
  </script>
</body>
</html>
